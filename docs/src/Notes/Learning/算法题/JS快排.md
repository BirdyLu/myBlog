### 快速排序的实现步骤

1. **选择基准**：从数组中选择一个基准元素（pivot），通常选择第一个、最后一个或中间的元素。
2. **分区操作**：重新排列数组，使得所有比基准元素小的元素位于基准元素左边，所有比基准元素大的元素位于基准元素右边。基准元素最终会处于排序后的正确位置。
3. **递归排序**：递归地对基准元素左右两边的子数组进行快速排序。

### 手写快速排序的代码
```javascript
function quickSort(arr) {
  // 如果数组长度小于等于1，直接返回数组（已经排好序）
  if (arr.length <= 1) {
    return arr;
  }

  // 选择基准元素，这里选择数组的最后一个元素作为基准
  const pivot = arr[arr.length - 1];
  const left = [];
  const right = [];
  
  // 分区操作
  for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  // 递归排序左边和右边的子数组，并合并结果
  return [...quickSort(left), pivot, ...quickSort(right)];
}

// 使用示例
const arr = [3, 6, 8, 10, 1, 2, 1];
const sortedArr = quickSort(arr);
console.log(sortedArr); // 输出: [1, 1, 2, 3, 6, 8, 10]
```

### 解释

1. **选择基准**：在这里，我们选择数组的最后一个元素作为基准（`pivot`）。
2. **分区操作**：遍历数组的前 `arr.length - 1` 个元素，将小于基准的元素放入 `left` 数组，将大于或等于基准的元素放入 `right` 数组。
3. **递归排序**：对 `left` 和 `right` 数组递归调用 `quickSort` 函数，最后将排序后的 `left`、基准元素和排序后的 `right` 合并。

### 复杂度分析

- **时间复杂度**：
  - 最佳情况：O(n log n)，当每次分割都能将数组均匀地分成两部分时。
  - 平均情况：O(n log n)。
  - 最坏情况：O(n^2)，当数组已经是排序好的或几乎排序好的时候，每次分割都不均匀。

- **空间复杂度**：O(log n)，递归调用栈的空间复杂度。

### 优化

1. **选择合适的基准**：为了避免最坏情况，基准的选择应尽可能均匀地分割数组。例如，使用“三数取中法”来选择基准。
2. **尾递归优化**：在某些编程语言中，尾递归可以优化递归调用的性能。对于 JavaScript，不同环境可能有不同的优化策略。
3. **随机选择基准**：选择基准的方法应该尽可能随机，以降低最坏情况的概率。