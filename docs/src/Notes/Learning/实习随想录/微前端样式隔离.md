---
updateTime: "2024-11-21 10:30"
desc: "微前端css样式隔离问题"
tags: "微前端"
outline: deep
---
# 微前端css样式隔离问题：
  *为什么会产生？* 
1. 多个应用程序共享同一个 DOM，如果子应用的 CSS 样式作用域不明确，它们的样式规则可能会影响其他子应用的 DOM 元素。例如，使用全局选择器（如 `*` 或 `body`）可能会导致所有子应用的样式都被影响。。
  2. 全局样式冲突：例如，如果两个应用定义了相同的 CSS 类名或全局标签选择器，浏览器会根据加载顺序应用最新的样式，导致某个应用的样式被覆盖或修改。
  3. 3.CSS 优先级问题： 浏览器解析 CSS 时根据优先级规则应用样式。如果多个微前端应用的 CSS 规则存在选择器优先级问题，可能会导致某些样式无法生效或错误应用到其他应用的元素上 
  4. 外部依赖样式引入冲突： 微前端应用通常会引入一些外部依赖库（如 Bootstrap、Ant Design 等）的 CSS。如果不同的应用引入了相同或版本不同的依赖库，样式可能会产生冲突，导致一些 UI 不符合预期。



*解决方案*:  

1. 提高样式优先级。单独引用一个自定义样式出来，使用 CSS Modules（CSS Modules 可以将 CSS 样式限定在特定的组件范围内，避免样式污染。使用 CSS Modules 时，样式会被编译成独特的类名，从而避免冲突。）
```less
.ant-modal-content:has(.comment-manager-match-modal) {
.ant-modal-close-x {
   width: 100% !important;
   height: 100% !important;
  }
}
//但是感觉这样写好奇怪，，，想改成下面这样
.comment-manager-match-modal .ant-modal-close-x {
  width: 100% !important;
  height: 100% !important;
}
//或者js动态操作
const modalContent = document.querySelector('.ant-modal-content');
if (modalContent && modalContent.querySelector('.comment-manager-match-modal')) {
  const closeButton = modalContent.querySelector('.ant-modal-close-x');
  if (closeButton) {
    closeButton.style.width = '100%';
    closeButton.style.height = '100%';
  }
}

```
**注意**：这种方法只能作为临时解决的措施，不可以根除病因，因为只能修改一个 class 类名样式，对其他的 class 类名，还需要每个都去设置样式优先级。

2. *使用 Ant Design 的 ConfigProvider*其他的项目都用的这个，其实这个是最规范的，为什么用第一种因为Protable第二种还没写这个功能。。。所以就算配置了这个还是没用
```tsx
<ConfigProvider
prefixCls={PrefixCls}
>
</ConfigProvider>

```
在 Vue 中，同样可以使用 `<a-config-provider>` 组件来实现样式隔离(具体看掘金文章)

3. 使用 Scoped Styles in Less 或 SCSS
其他的看下面这篇文章吧，我觉得上面三个可以解决大部分场景了
https://juejin.cn/post/7394336779792269322?searchId=20240923204420805CEFDDB9A880188C05

##### Protable的reload：
https://procomponents.ant.design/components/table#actionref-%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91
###### ActionRef 手动触发
有时我们要手动触发 table 的 reload 等操作，可以使用 actionRef，可编辑表格也提供了一些操作来帮助我们更快地实现需求。
```ts
interface ActionType { 
reload: (resetPageIndex?: boolean) => void;
reloadAndRest: () => void; 
reset: () => void; 
clearSelected?: () => void; 
startEditable: (rowKey: Key) => boolean; 
cancelEditable: (rowKey: Key) => boolean; 
} 
const ref = useRef<ActionType>(); 
<ProTable actionRef={ref} />; 
// 刷新 
ref.current.reload(); 
// 刷新并清空,页码也会重置，不包括表单
ref.current.reloadAndRest(); 
// 重置到默认值，包括表单 
ref.current.reset(); 
// 清空选中项 
ref.current.clearSelected(); 
// 开始编辑
ref.current.startEditable(rowKey);
// 结束编辑 
ref.current.cancelEditable(rowKey);
```

##### 公共组件的功能扩展（不知道这么总结对不对）
改公共组件一定不能去改以前的逻辑，能通过以前的逻辑扩展就扩展来写，不能就自己重写。
```ts
<Form.Item name="season_id" label="剧集ID" rules={[{ required: true }]}>
<SeasonSearcher extraParams={{ seasonStatus: 'ONLINE' }} />
</Form.Item>
```
>SeasonSearcher是来自@bilibili/marin-kaitian-shared一个公共组件，只能支持搜索Title。但是产品说新增要可以搜索season_id。
我当时想的是用useState来写然后把ssid传给组件。但是如果改动这里的逻辑，所有的用了公共库的代码都要改。所以是添加一个扩展的param
```tsx
export const SeasonSearcher = ({
//...省略其他的
extraParams = {},
}: ISeasonSearcherProps) => {
//...省略其他的
const { seasonList, loading } = useSeasonSearch({

offset: 100,

pageNo: 1,

title,

...(seasonType ? { type: Number(seasonType) } : {}),

...extraParams,

})
//...省略其他的
```


```tsx
export const useSeasonSearch = (
params: ISeasonSearchReq,
options: UseQueryOptions = {}
) => {
const query = useQuery({
queryKey: ['useSeasonSearch', params],
queryFn: async () => {
//判断title为数字还是非数字，因为title上就有ssid
// title为非数字场景
const titleMatchList = await getSeasonList(params)
// title为数字场景
if (params.title && isNumericString(params.title)) {
const idMatchList = await getSeasonList({
...omit(params, 'title'),
seasonId: params.title,
})
return [...idMatchList, ...titleMatchList]
}
return titleMatchList
},
//...省略其他的


背景
在开发中，常见的样式冲突问题有：

基础依赖库的共享：如 antd.css 在多个应用中引入，可能导致样式冲突。
自定义类名重复：开发者虽然习惯不同，但是可能自定义的class类名相同，导致样式相互覆盖。


图中的样式，在接入微前端后，并没有满足我们的 UI 预期。通过查看，发现是 CSS 代码被覆盖了！

相同的 padding 属性，在自己的代码中没有发现，却在微前端的某个应用项目中发现！

1. 提高样式的优先级
通过增加样式选择器的优先级，可以确保特定样式优先应用，而不会被其他样式覆盖。

```css
/* 自定义样式 */
.dialogsmodel .ant-modal-content {
  padding: 8px 0 10px; /* 确保优先级高于主应用或者其他应用 */
}
```

注意：这种方法只能作为临时解决的措施，不可以根除病因，因为只能修改一个 class 类名样式，对其他的 class 类名，还需要每个都去设置样式优先级。


2. 使用 Ant Design 的 ConfigProvider（强烈推荐使用）
Ant Design 提供的 ConfigProvider 组件可以用来配置全局样式，通过设置 prefixCls 来改变默认的样式前缀，避免样式冲突。

```tsx
import { ConfigProvider } from 'antd';

function App() {
  return (
    <ConfigProvider prefixCls="my-ant">
      <Button>Button</Button>
    </ConfigProvider>
  );
}
```

在 Vue 中，同样可以使用 <a-config-provider> 组件来实现样式隔离：
```html
<a-config-provider prefixCls="my-ant">
   <Button>Button</Button>
</a-config-provider>
```


修改 ant.css 源码：
```css
:deep(.my-ant-btn){
  font-size: 20px;
}
```

3. 使用 Scoped Styles in Less 或 SCSS（强烈推荐使用）
通过使用 <style scoped lang="less"> 或 <style scoped lang="scss"> 标签，可以实现样式的局部作用域，从而避免样式冲突。
Vue 示例：
```html
<template>
  <button class="btn-custom">Button</button>
</template>

<style scoped lang="less">
.btn-custom {
  color: red; /* 自定义样式 */
}
</style>

SCSS 示例：
```html
<template>
  <button class="btn-custom">Button</button>
</template>

<style scoped lang="scss">
.btn-custom {
  color: red; /* 自定义样式 */
}
</style>

4. 使用 CSS Modules
CSS Modules 可以将 CSS 样式限定在特定的组件范围内，避免样式污染。使用 CSS Modules 时，样式会被编译成独特的类名，从而避免冲突。
```css
// App.css
.ant-btn {
  color: red;
}
```

```tsx
// App.jsx
import styles from './App.css';

function App() {
  return <Button className={styles.ant-btn}>Button</Button>;
}
```

其他方案
是否还有其他方案可以作为调研的方向呢，当然是有的，但是项目中不常用。
5. 动态加载样式
在子应用加载时动态注入其独立的样式表，以确保样式独立。
```ts
function loadStyle(url) {
  const link = document.createElement('link');
  link.rel = 'stylesheet';
  link.href = url;
  document.head.appendChild(link);
}

// 在子应用启动时调用
loadStyle('子应用的样式地址');
```

大家可以思考下，这个是借用了什么实现？
6. 使用 Shadow DOM
Shadow DOM 可以完全隔离不同应用的样式，实现样式的独立性。
```tsx
function App() {
  const shadowRoot = document.createElement('div').attachShadow({ mode: 'open' });
  shadowRoot.innerHTML = `
    <style>
      .ant-btn { color: red; }
    </style>
    <button class="ant-btn">Button</button>
  `;
  return shadowRoot;
}
```
在微前端架构下，实现样式隔离对于保持各子应用的独立性和一致性至关重要。以上提供的解决方案在实际应用中已经得到验证，真实可用。
通过配置方法2和方法3，可以实现合理的样式管理，使开发者在开发过程中无需担心样式覆盖问题。这不仅能有效避免主应用或其他子应用的样式干扰，还能防止自己项目中类名重复导致的冲突，从而大幅提升项目开发的便捷性、稳定性和可维护性。
